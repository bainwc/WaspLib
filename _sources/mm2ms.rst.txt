
MM2MS
=====
Methods to handle MM2MS (Minimap to MainScreen). Extends SRL's MM2MS.


------------

type TRSMainScreenShape
~~~~~~~~~~~~~~~~~~~~~~~~~

This record holds information about the shape of a TRSWalkerObject and it's rotation.

TRSMainScreenShape.Shape has 3 values, X, Y and Z. X and Y are how wide a object is, measured in game tiles.
Z is the object height which has to be guessed and tested for a good value.

For example, a bank chest would be roughly [1, 1, 4].
A bank booth would be roughly [1, 1, 8].

Angle is used to rotate an object and should be done in radians.


------------

MM2MS.SetupZoom
~~~~~~~~~~~~~~~
.. code-block:: pascal

 procedure TMM2MS.SetupZoom;

Wrapper procedure to easily setup MM2MS.ZoomLevel.

Example
-------
.. code-block:: pascal  

  MM2MS.SetupZoom;
  WriteLn MM2MS.ZoomLevel;


------------

Minimap.GetFaceablePoints
~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.GetFaceablePoints(): TPointArray;

Gives the center point of the 8 tiles that are directly close to the player.
This are the tiles the player can "face".


------------

Minimap.GetCardinalPoints
~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.GetCardinalPoints(): TPointArray;

Gives the center point of the 4 cardinal points (North, West, South and East) that are directly close to the player.
This are the tiles the player can "face".


------------

Minimap.PointWithinZoom
~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.PointWithinZoom(p: TPoint; out Corner: TPoint): Boolean;
.. code-block:: pascal

 function TRSMinimap.PointWithinZoom(p: TPoint): Boolean; overload;
.. code-block:: pascal

 function TRSMinimap.PointWithinZoom(tpa: TPointArray): Boolean; overload;

Method used to know if a point is within reach of the Zoom rectangle without adjusting the zoom level.
Check TRSMinimap.GetZoomRectangle for information on the Zoom rectangle.

Example
-------
.. code-block:: pascal  

  WriteLn Minimap.PointWithinZoom([620, 100]);


------------

Minimap.FacePoint
~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.FacePoint(p: TPoint; randomness: Int32 = 0): Boolean;

This method will rotate the camera so that **P** is within the zoom rectangle without adjusting the zoom level.

Example
-------
.. code-block:: pascal  

  WriteLn Minimap.FacePoint([620, 100]); //keep in mind this example uses a static point, you will probably never do this.


------------

MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMainScreen.FacePoint(p: TPoint; randomness: Int32 = 0): Boolean; override;

TODO: ADD THIS TO SRL.

Overriden for a more desirable functionality.
The original function simply makes the point be straight up of the mainscreen, without regard wether it's visible or not.
This version of the function instead just makes sure that the point is visible as long as it `Minimap.PointWithinZoom` is true.


------------

Minimap.GetZoomToPoint
~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.GetZoomToPoint(p: TPoint; randomness: Int32 = 0): Int32;

TODO: THIS NEEDS TO BE REWORKED. IT'S NOT RELIABLE RIGHT NOW.

This function gives us a zoom level where **P** would be visible in the MainScreen.

Example
-------
.. code-block:: pascal  

  p := Minimap.GetDots(ERSMinimapDot.ITEM)[0]; //find an item dot and returns it's coodinates.
  Options.SetZoomLevel(Minimap.ZoomToVisiblePoint(p));


------------

Minimap.SetZoomToPoint
~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.SetZoomToPoint(p: TPoint; randomness: Int32 = 0): Boolean;

TODO: ADD THIS TO SRL WHEN TRSMinimap.ZoomToVisiblePoint() WORKS PROPERLY.

This function adjusts the zoom level so **P** TRSMinimap.PointWithinZoom() is true.


------------

Minimap.MakePointVisible
~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.MakePointVisible(p: TPoint): Boolean;
.. code-block:: pascal

 function TRSMinimap.MakePointVisible(tpa: TPointArray): Boolean; overload;

TODO: ADD THIS TO SRL WHEN TRSMinimap.ZoomToVisiblePoint() WORKS PROPERLY.

Uses both Minimap.ZoomToPoint() and Minimap.FacePoint() to make a point visible on the Mainscreen.


------------

Minimap.GetCuboidMSEx
~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.GetCuboidMSEx(loc: TPoint; shape: TRSMainScreenShape; startHeight: Double = 0; offset: Vector2 = [0, 0]; roll: Single = $FFFF): TCuboid;

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.

To put it simply, this will will first calculate a floor rectangle with **tile.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **tile.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon.

Example
-------
.. code-block:: pascal  

  P := Minimap.GetDots(ERSMinimapDot.PLAYER)[0];         //find a player dot and returns it's coodinates.
  offset := [2 , 2];                                     //Minimap dots are actually returned with a slight offset of -2, -2 when converting them to the mainscreen.
  Debug(Minimap.GetCuboidMS(P, [1, 1, 7], offset));     //This will draw a polygon around the nearest player.


------------

Minimap.GetCuboidMS
~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.GetCuboidMS(loc: TPoint; tile: Vector3 = [1, 1, 4]; offset: Vector2 = [0, 0]; roll: Single = $FFFF): TPointArray;

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.

To put it simply, this will will first calculate a floor rectangle with **tile.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **tile.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon.

Example
-------
.. code-block:: pascal  

  P := Minimap.GetDots(ERSMinimapDot.PLAYER)[0];         //find a player dot and returns it's coodinates.
  offset := [2 , 2];                                     //Minimap dots are actually returned with a slight offset of -2, -2 when converting them to the mainscreen.
  Debug(Minimap.GetCuboidMS(P, [1, 1, 7], offset));     //This will draw a polygon around the nearest player.


------------

Minimap.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.GetTileArrayMS(locArray: TPointArray; tile: Vector3; offset: TPoint = [0, 0]; angle: Single = $FFFF): TRectArray;

Gives you an array of rectangles of several tiles and they can be multiple tiles each.
For an explanation of parameters check Minimap.GetTileMS.

Example
-------
.. code-block:: pascal  

  tpa := Minimap.GetDots(ERSMinimapDot.NPC);   //find all npc dots and returns their coodinates.
  Debug(Minimap.GetTileArrayMS(P, [2, 3, 0])); //This will draw a recangle that is 2 by 3 tiles in the mainscreen where each NPC is.


------------

Minimap.GetCuboidArrayMSEx
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal

 function TRSMinimap.GetCuboidArrayMSEx(locArray: TPointArray; shapeArray: TRSMainScreenShapeArray; startHeights: TDoubleArray; offset: Vector2 = [0, 0]; angle: Single = $FFFF): TCuboidArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetCuboidMS** for more information.

Example
-------
.. code-block:: pascal  

  tpa := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetCuboidArrayMS(tpa, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.


------------

Minimap.GetCuboidArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~
.. code-block:: pascal


  function TRSMinimap.GetCuboidArrayMS(locArray: TPointArray; shapeArray: TRSMainScreenShapeArray; offset: Vector2 = [0, 0]; angle: Single = $FFFF): TCuboidArray;
  function TRSMinimap.GetCuboidArrayMS(locArray: TPointArray; shape: TRSMainScreenShape; offset: Vector2 = [0, 0]; angle: Single = $FFFF): TCuboidArray; overload;
  function TRSMinimap.GetCuboidArrayMS(locArray: TPointArray; tile: Vector3; offset: Vector2 = [0, 0]; angle: Single = $FFFF): TCuboidArray; overload;

Gives you an array of mainscreen polygons. Read **Minimap.GetCuboidMS** for more information.

Example
-------
.. code-block:: pascal  

  tpa := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetCuboidArrayMS(tpa, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.


------------
